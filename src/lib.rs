/*
 * indent-stack
 *
 * Copyright (C) 2019 chankyin
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//! Provides a wrapper for integer types with modular arithmetic behaviour.
//!
//! Since modular arithmetic is commonly used with a specific prime modulus, this crate removes the
//! cost of storing the modulus by hardcoding it in the definition and generating definitions with
//! a macro, enhancing performance.
//!
//! This also automatically moves modulus equality checking (because values of different modulo
//! cannot be added directly) from runtime to compile time, enhancing stability.

#![no_std]
#![cfg_attr(nightly, feature(underscore_const_names, doc_cfg))]

extern crate alloc;

use alloc::vec::Vec;
use core::fmt::Debug;
use core::ops::{Add, Div, Mul, Rem, Sub};

pub use num_traits::{One, Zero};

mod def_macro;

/// The Modular trait is implemented by all modular-arithmetic-defining classes.
pub trait Modular<T: Copy + Debug + Default + Add + Sub + Mul + Rem>: 
Copy + Debug + From<T> + Add + Sub + Mul + Div + Eq + Zero + One {
    /// The modulus of this type.
    const MOD: T;

    /// The remainder of the value divided by `MOD`.
    fn remainder(&self) -> T;

    /// Raises the value to the `n`th multiplicative power.
    fn pow(self, n: usize) -> Self;

    /// Calculates the modular inverse of the value assuming that the modulus is prime.
    ///
    /// # Panics
    /// In debug mode, the function panics if called on a type with a composite modulus.
    fn prime_inv(self) -> Self;

    /// Calculates the modular inverse of the value with Extended Euclidean Algorithm.
    ///
    /// This algorithm assumes that the value and the modulus are coprime.
    ///
    /// # Returns
    /// Returns `Some` if the inverse exists, `None` otherwise.
    ///
    /// # Panics
    /// In debug mode, the function panics if the value and the modulus are not coprime.
    fn coprime_inv(self) -> Option<Self>;

    /// Calculates the modular inverse of the value by brute force algorithm.
    ///
    /// # Returns
    /// Returns `Some` if the inverse exists, `None` otherwise.
    fn brute_force_inv(self) -> Option<Self>;

    /// Chooses an algorithm to calculate the modular inverse of the value
    ///
    /// # Returns
    /// Returns `Some` if the inverse exists, `None` otherwise.
    fn inv(self) -> Option<Self>;
}

#[cfg_attr(nightly, cfg(rustdoc))]
#[cfg_attr(not(nightly), cfg(nightly))] // if true then false
def_modular!(ExampleModular101 : u16 | i16, 101 ; example_modular_101_lbl
             #[doc = "This struct is an example struct used to demonstrate what is generated by the [`def_modular`](macro.def_modular.html) macro."]
             #[doc = ""]
             #[doc = "Do not try to use this type anywhere (including tests), because this type is only declared in `cfg(rustdoc)`."]
             );

#[cfg(test)]
mod tests;

#[doc(hidden)]
pub fn is_prime<T>(n: T) -> bool
where T: Copy + Add<Output = T> + Mul<Output = T> + Rem<Output = T> + Eq + Ord + One + Zero {
    let mut i = T::one() + T::one();
    while i * i <= n {
        if n % i == T::zero() {
            return false;
        }
        i = i + T::one();
    }
    true
}

#[doc(hidden)]
pub fn list_prime_factors<T>(mut n: T) -> Vec<T>
where T: Copy + Add<Output = T> + Div<Output = T> + Rem<Output = T> + Eq + Ord + One + Zero {
    let mut list = Vec::<T>::new();
    let mut p = T::one() + T::one();
    while p <= n {
        if n % p != T::zero() {
            continue;
        }
        list.push(p);
        while n % p == T::zero() {
            n = n / p;
        }
        p = p + T::one();
    }
    list
}

#[doc(hidden)]
pub fn extended_gcd<T>(a: T, b: T) -> (T, T, T)
where T: Copy + Sub<Output = T> + Mul<Output = T> + Div<Output = T> + Rem<Output = T> + Eq + One + Zero {
    if a == T::zero() {
        return (T::zero(), T::one(), b);
    }
    let (x, y, g) = extended_gcd(b % a, a);
    (y - (b / a) * x, x, g)
}
